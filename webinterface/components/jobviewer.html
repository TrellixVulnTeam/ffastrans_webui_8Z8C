<html>

<script src="/socket.io/socket.io.js"></script>
<!--<script src="../dependencies/dhtmlx/standalone/dhtmlxCommon/codebase/dhtmlxcommon.js"></script>
<script src="../dependencies/dhtmlx/standalone/dhtmlxCommon/codebase/dhtmlxcontainer.js"></script>
<script src="../dependencies/dhtmlx/standalone/dhtmlxCommon/codebase/dhtmlxcore.js"></script>
<script src="../dependencies/dhtmlx/standalone/dhtmlxGrid/codebase/dhtmlxgrid.js"></script>
<script src="../dependencies/dhtmlx/standalone/dhtmlxGrid/codebase/ext/dhtmlxgrid_srnd.js"></script>
<script src="../dependencies/dhtmlx/standalone/dhtmlxGrid/codebase/ext/dhtmlxgrid_filter.js"></script>

<script src="../dependencies/dhtmlx/standalone/dhtmlxLayout/codebase/dhtmlxlayout.js"></script>
<script src="../dependencies/dhtmlx/standalone/dhtmlxMessage/codebase/dhtmlxmessage.js"></script>
<script src="../dependencies/dhtmlx/standalone/dhtmlxWindows/codebase/dhtmlxwindows.js"></script>
<script src="../dependencies/dhtmlx/standalone/dhtmlxMenu/codebase/dhtmlxmenu.js"></script>
-->
<script src="../dependencies/dhtmlx/dhtmlx.js"></script>
<link rel="stylesheet" href="../dependencies/dhtmlx/dhtmlx.css" type="text/css"> 
 <script src="../dependencies/dhtmlx/vault/vault.js"></script>
<link rel="stylesheet" href="../dependencies/dhtmlx/vault/vault.css" type="text/css"> 
<script src="../dependencies/jquery/jquery.js"></script>
<link rel="icon" href="favicon.ico?v=1.1">
<link rel="stylesheet" href="../dependencies/fontawesome/css/all.css"/>

<style>
    /* it's important to set width/height to 100% for full-screen init */
    html, body {
        width: 100%;
        height: 100%;
        margin: 0px;
        overflow: hidden;
        color: #333;
        font: 14px Helvetica, Arial, sans-serif;
        line-height: 18px;
    }
    header {
        background: #333;
        border-bottom: 3px solid #aaa;
        height: 80px;
    }
    header h1 {
        color: #fff;
        margin: 0 0 3px;
        font-size: 22px;
        padding: 12px 9px 0;
        margin-top: 1px;
    }
    header p {
        color: #ccc;
        font-size: 8 px;
        font-weight: bold;
        padding: 0 27px;
    }
    .counter_jobs {
      color: #ccc;
      border-radius: 5px;
      border: 2px solid #ccc;
      width: 80px;
      height: 60px;
      background-color: #333;
      font-size:20px;
      font-family:"Times New Roman";
      display:inline;
      margin-bottom: 0;
      position: absolute;
      display: block;
      font-size:12px;
      font-family:arial;
      margin-top: 8px;
    }
    .div_active_jobs {
        margin-left:350px;
    }
    .div_queued_jobs {
        margin-left:450px;
    }
    .div_success_jobs {
        margin-left:550px;
    }
    .div_error_jobs {
        margin-left:650px;
    }
    .div_cancel_jobs {
        margin-left:750px;
    }
    .itemrowtopright {
        float:right;
        margin-right:0;
        margin-top:10px;
        margin-right:10px;
        height: 50px;
        color:white;
    }
    .header_counter_number{
      margin: auto;
      width: 50%;
      height: 60%;
      text-align: center;
      vertical-align: middle;
      line-height: 30px;
      font-size: 20px;
      display: block;
      margin-top: 3px;
      }
    .steinar {
        height: 38;
        margin-top: 16px;
    }
    .harry{
    
    }
    
    .ffastransheadertext{
       display: inline-block;
    }
    .instancename{
       margin-top: 5px;
       display: inline-block;
    }
    .description{
       margin-top: 0px;
    }
    
    .progressbar {
      border-radius: 5px;

      height: 80%;
      background-color: #4CAF50;
      text-align: center;
    }
    
      /*.dhxlayout_base_material div.dhx_cell_layout {
          background-color: #333;
      }
      .body.dhxlayout_base_material{
          //background-color: #AAA;
      }*/
      
        /*layout headers (big blue lines)*/     
      .dhxlayout_base_material div.dhx_cell_layout div.dhx_cell_hdr{
        height:25px;
        line-height: 23px;
        font-size : 12px;
      }
  
      /*collapse icon in layout header*/
      .dhxlayout_base_material div.dhx_cell_layout div.dhx_cell_hdr div.dhxlayout_arrow.dhxlayout_arrow_ha{
        background-position: -32px -5px;
        z-index: 1;
        margin-top: -3;
      }
      /*collapse icon in layout header*/
      div.dhx_cell_layout div.dhx_cell_hdr div.dhxlayout_arrow.dhxlayout_arrow_vb{
        margin-top: -8px;
        z-index: 1;
      }
      
</style>

<script>
/* init SOCKET.IO */
var socket = io();

/* GLOBALS */
var mainLayout,runningJobGrid,finishedJobGrid,m_serverconfig;
var m_rowColorError = "#f28d80"
var m_rowColorCancelled = "#ffcc80"
/* STRUCTS */
var m_jobStates = ["Error","Success","Cancelled","Unknown"]; 

/*load config from server*/
function loadserverconfig(){
   $.ajax({
        url:  ("/getserverconfig") ,
        type: "GET",
        success: function (response) {
            m_serverconfig = JSON.parse(response)
            init();
        },
        error: function (xhr, status) {
            dhtmlx.message("Fatal error, could not load serverconfig. " );
            document.body.innerHTML="Fatal error, could not load serverconfig. "+ xhr.responseText;
        }
    });
}

/* build basic page layout and init periodic job loading*/
function init(){

    //kick off DB maintenance verytime a client opens the UI - fire and forget
    $.get( "/deleteoldrecords" );
    
    //check if html5 features supported
    if (typeof(Storage) !== "undefined") {
    } else {
        dhtmlx.message("ERROR, no html5 store support, cannot save view state")
    }
  
    
    mainLayout = new dhtmlXLayoutObject({
   // mainLayout = headerLayout.cells("b").attachLayout({
        parent: document.body,  
        pattern: "2E"           
    });
    mainLayout.cells("a").setText("Running");
                                        
    mainLayout.cells("b").setText("Finished");
    mainLayout.cells("b").setWidth($(document).width()/3);
    //mainLayout.cells("c").setText("Finished");
    mainLayout.cells("a").setHeight($(document).height()/3.5);
    restoreLayoutSizes(mainLayout,"mainLayout");

    runningJobGrid = mainLayout.cells("a").attachGrid();
    //runningJobGrid.setImagesPath("../dependencies/dhtmlx/skins/skyblue_grey/imgs/");
    runningJobGrid.setSkin("dhx_skyblue");
    finishedJobGrid = mainLayout.cells("b").attachGrid();
    //finishedJobGrid.setImagesPath("../dependencies/dhtmlx/skins/skyblue_grey/imgs/");
    finishedJobGrid.setSkin("dhx_skyblue");
    var headerMenu = mainLayout.cells("a").attachMenu({                                               
        items:[
             {id:"abort", text:'<i class="fas fa-stop"></i>Abort'},
             {id:"pause", text:'<i class="fas fa-pause"></i>Pause'}, 
             {id:"resume", text:'<i class="fas fa-play"></i>Resume'},
             {id:"log", text:'<i class="fas fa-info"></i>Log'},
          ]
    });
    
    var headerMenuFinished = mainLayout.cells("b").attachMenu({                                               
        items:[
             {id:"log", text:'<i class="fas fa-info"></i>Log'},
             {id:"delsel", text:'<i class="fas fa-trash-alt"></i>Delete Selected'},
             {id:"delall", text:'<i class="fas fa-trash-alt"></i>Delete All'},
          ]
    });
    
//events for button clicks
    headerMenu.attachEvent("onClick", function(id, zoneId, cas){k
            if (id == "abort") {
                abortJob()
            }
            if (id == "pause") {
                pauseResumeJob(id,"PUT")
            }
            if (id == "resume") {
                pauseResumeJob(id,"PUT")
            }
            if (id == "log") {
                openLogViewer(runningJobGrid)
            }
    });
    headerMenuFinished.attachEvent("onClick", function(id, zoneId, cas){
            if (id == "log") {
                openLogViewer(finishedJobGrid)
            }
            if (id == "delsel") {
            //delete selected jobs
                if (!finishedJobGrid.getSelectedRowId()){
                    dhtmlx.alert("Please select rows to delete " );
                    return;
                }
                var selectedRowIds = finishedJobGrid.getSelectedRowId().split(',');
                var array_to_delete = [];
                selectedRowIds.forEach(function(rId) {
                    var id = (finishedJobGrid.cells(rId,finishedJobGrid.getColIndexById("_id")).getValue());
                    array_to_delete.push(parseInt(id));
                    finishedJobGrid.deleteRow(rId);
                })
                socket.emit("deletejob", JSON.stringify( array_to_delete));//note, custom structure for socket.emit messages
                
            }
            if (id == "delall") {
            //delete all jobs
               dhtmlx.confirm({
								title:"Delete ALL Jobs",
								type:"confirm-error",
								text:"Really delete ALL Jobs?",
                                callback:function(yesno){
                                    if (yesno){
                                         socket.emit("deletealljobs");//note, custom structure for socket.emit messages
                                         finishedJobGrid.clearAll();
                                    }
                                }
							});
            }
            
            
    });
    
    runningJobGrid.setInitWidthsP(m_serverconfig['STATIC_INIT_RUNNING_GRID_COL_WIDTHS_PERCENT']);          //the widths of columns 
    runningJobGrid.setHeader("State,Workflow,Host,Processor,File,Job Start,End,Duration,Status,Splitindex,Progress");//the headers of columns    
    configureJobGrid(runningJobGrid);
    finishedJobGrid.setInitWidthsP(m_serverconfig['STATIC_INIT_FINISHED_GRID_COL_WIDTHS_PERCENT']); 
    finishedJobGrid.setHeader("State,Workflow,Job Start,Duration,End,File,Outcome,ID");//the headers of columns 
    finishedJobGrid.setColumnIds("state,wf_name,job_start,duration,job_end,file,outcome,_id");
    finishedJobGrid.enableSmartRendering(true,100);
    finishedJobGrid.setAwaitedRowHeight(25);
    finishedJobGrid.setImagePath("../dependencies/dhtmlx/imgs");                 
    finishedJobGrid.attachHeader("#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter"); 
    
    finishedJobGrid.setColAlign("left,left,left,left,left,left,left,left,left,left,left");       //the alignment of columns   
    finishedJobGrid.setColTypes("ed,ed,ed,ed,ed,ed,ed,ed,ed,ed,ed,ed,ed");                //the types of columns  
    finishedJobGrid.setColSorting("str,str,str,str,str,str,str,str,str,str,str,str");          //the sorting types   
    finishedJobGrid.enableMultiselect(true);
    finishedJobGrid.init();      //finishes initialization and renders the grid on the page 
    finishedJobGrid.load("/gethistoryjobsajax?filtercol=job_end&direction=des","js")
    
    finishedJobGrid.attachEvent("onBeforeSorting",function(colindex,type,dir){
        //as we sort on the server instead of the client, we need to override the filter function
        var fieldname = this.columnIds[colindex];
        finishedJobGrid.clearAll()
        finishedJobGrid.load("/gethistoryjobsajax?filtercol="+fieldname+"&direction="+dir,"js")
        finishedJobGrid.setSortImgState(true,colindex,dir);//this is important to let the js grid know how it is sorted (not just the user)
        return false ;
    });    
    finishedJobGrid.attachEvent("onRowCreated", function(rId,rObj,rXml){
            var state= finishedJobGrid.cells(rId,0).getValue();
            if (state =="Error"){
                
                finishedJobGrid.setRowColor(rId,m_rowColorError);
            }            
            if (state =="Cancelled"){
                
                finishedJobGrid.setRowColor(rId,m_rowColorCancelled);
            }
    /*
        console.log("onRowCreated")
        //data was loaded from the server, re-color the rows
        finishedJobGrid.forEachRow(function(id){
            var state= finishedJobGrid.cells(id,0).getValue();
            if (state =="Error"){
                
                finishedJobGrid.setRowColor(id,m_rowColorError);
            }            
            if (state =="Cancelled"){
                
                finishedJobGrid.setRowColor(id,m_rowColorCancelled);
            }
        });
        */
    });

    finishedJobGrid.attachEvent("onFilterStart", function(indexes,values){
        //we need to override grid filter method as we filter on the server
        var filterobj = {};
        var activefiltercount = 0;
        for (i=0;i<values.length;i++){
            if (values[i] != ("")){
                var fieldname = this.columnIds[i];
                filterobj[fieldname] = values[i];
                activefiltercount++;
            }
        }
        if (activefiltercount != 0){
            finishedJobGrid.clearAll();
            finishedJobGrid.load("/gethistoryjobsajax?filtercol="+fieldname+"&direction=des" +  "&filterobj=" +JSON.stringify(filterobj)  ,"js");
        }else{
            //filter is empty, restore normal view
            finishedJobGrid.clearAndLoad("/gethistoryjobsajax?filtercol=job_end&direction=des","js")
        }
        return true;
    });
    
    mainLayout.attachEvent("onPanelResizeFinish", function(){
        saveLayoutSizes(mainLayout,"mainLayout");
    });
    
    finishedJobGrid.setSortImgState(true,2,"desc");
    runningJobGrid.setSortImgState  (true,5,"desc");  
    mainLayout.cells("a").progressOn();
    /* events from socket.io*/
    /*socket.on('activejobs', function(msg){
        mainLayout.cells("a").progressOff();
        //instead of polling periodically from the client, the server polls periodically and notifies connected clients with the job arrays
        addActiveJobsToGrid(runningJobGrid,JSON.parse(msg))
    });*/
    socket.on('newhistoryjob', function(msg){
        //server informs us about new history jobs in db, if there are new, we fetch them
            var obj =  msg;
            //we do not like to disturb user interaction, so instead of //finishedJobGrid.filterByAll(); we just add a row
            var rowValues = [obj.state,obj.wf_name,obj.job_start,obj.duration,obj.job_end,obj.file,obj.outcome] //state,wf_id,job_start,duration,job_end,file,duration,outcome
               finishedJobGrid.addRow(obj.guid,rowValues,0);
                if (obj.state =="Error"){
                    finishedJobGrid.setRowColor(obj.guid,m_rowColorError);
                }            
                if (obj.state =="Cancelled"){
                    finishedJobGrid.setRowColor(obj.guid,m_rowColorCancelled);
                }
    });

    socket.on('queuedjobs', function(msg){
		if (JSON.parse(msg)){
			addQueuedJobsToGrid(runningJobGrid,JSON.parse(msg),"queued");
		}
        mainLayout.cells("a").progressOff();
    });
	socket.on('activejobs', function(msg){    
        addActiveJobsToGrid(runningJobGrid,JSON.parse(msg))
        mainLayout.cells("a").progressOff();
    });
    socket.on('error', function(msg){
     dhtmlx.message(msg);
    });
    socket.on('msg', function(msg){
     dhtmlx.message(msg);
    });
    
    if (!JSON.parse(m_serverconfig['STATIC_USE_PROXY_URL'])){
        window.setInterval(function(){getQueuedJobs(runningJobGrid)},parseInt(3000));
        window.setInterval(function(){getActiveJobs(runningJobGrid)},parseInt(3000));
        window.setInterval(function(){getFinishedJobs(finishedJobGrid)},parseInt(3000));
        getQueuedJobs(runningJobGrid);
        getActiveJobs(runningJobGrid);
        getFinishedJobs(finishedJobGrid);
    }
}


function delete_jobs(array_of_rows){

    var selectedRowIds = runningJobGrid.getSelectedRowId().split(',');
    selectedRowIds.forEach(function(rId) {
        var jobObj = runningJobGrid.getUserData(rId,"jobobject");
        var splitid = parseInt(runningJobGrid.cells(rId,9).getValue()) ;
        var postBody = {"action": pause,"split": splitid};  
        socket.emit("pausejob", JSON.stringify({"id":jobObj.job_id,"body":postBody}));//note, custom structure for socket.emit messages
        dhtmlx.message("Command " + pause +" emitted:" + JSON.stringify(postBody))
    })
}

function saveLayoutSizes(dhxLayout,name){
//store layout cells height and with into html5 storage (in percentage of document height)
    var aw = (dhxLayout.cells("a").getWidth()/document.body.scrollWidth ) ;
    var ah = (dhxLayout.cells("a").getHeight()/document.body.scrollHeight ) ;
    var bw = (dhxLayout.cells("b").getWidth()/document.body.scrollWidth ) ;
    var bh = (dhxLayout.cells("b").getHeight()/document.body.scrollHeight ) ;
    localStorage.setItem(name+"_aw",aw);
    localStorage.setItem(name+"_ah",ah);
    localStorage.setItem(name+"_bw",bw);
    localStorage.setItem(name+"_bh",bh);
    
}

function restoreLayoutSizes(dhxLayout,name){
    if (localStorage.getItem(name+"_aw")){
        var aw = localStorage.getItem(name+"_aw");
        var ah = localStorage.getItem(name+"_ah");
        var bw = localStorage.getItem(name+"_bw");
        var bh = localStorage.getItem(name+"_bh");
        dhxLayout.cells("a").setWidth(aw*document.body.scrollWidth);
        dhxLayout.cells("a").setHeight(ah*document.body.scrollHeight);
        dhxLayout.cells("b").setWidth(bw*document.body.scrollWidth);
        dhxLayout.cells("b").setHeight(bh*document.body.scrollHeight);
    }
}

function onHeaderClick(){
    window.open("http://www.ffastrans.com");
}

function openLogViewer(dhxgrid){
    if (!dhxgrid.getSelectedRowId()){
        dhtmlx.alert("Please select a Job" );
        return;
    }
    var selectedRowIds = dhxgrid.getSelectedRowId().split(',');
    var win_offset = 0;
    selectedRowIds.forEach(function(rId) {
        var jobObj = dhxgrid.getUserData(rId,"jobobject");
        var dhxwins = new dhtmlXWindows();
        //dhxwins.attachViewportTo(window.parent.document.body);
        var win = dhxwins.createWindow("Workflow",  50 + win_offset, 150 + win_offset, 1200, 800);
        win_offset+=30;
         win.setText("Log ");
         
        var logGrid = win.attachGrid();  
        logGrid.setImagesPath("../dependencies/dhtmlx/imgs/");
        logGrid.setHeader("Time,Processor,Host,PID,Message");//the headers of columns  
        logGrid.attachHeader("#text_filter,#text_filter,#text_filter,#text_filter,#text_filter");  
        logGrid.setInitWidthsP("10,10,10,5,*");          //the widths of columns  
        logGrid.setColAlign("left,left,left,left.left");       //the alignment of columns   
        logGrid.setColTypes("ed,ed,ed,ed,ed");                //the types of columns  
        logGrid.setColSorting("str,str,str,int,str");          //the sorting types    
        logGrid.enableMultiline(true); 
        logGrid.init();      //finishes initialization and renders the grid on the page 
        
        if (jobObj.job_id){
            //we have a job_id that eases the life of finding jobs
            var url = "/logparser?job_id=" +encodeURI(jobObj.job_id) +"&wf_name=" + encodeURI(jobObj.wf_name) ;
            logGrid.load(url,"json")
        }else{
            var file = (dhxgrid.cells(rId,dhxgrid.getColIndexById("file")).getValue());
            var job_end = (dhxgrid.cells(rId,dhxgrid.getColIndexById("job_end")).getValue());
            var job_start = (dhxgrid.cells(rId,dhxgrid.getColIndexById("job_start")).getValue());
            var wf_name = (dhxgrid.cells(rId,dhxgrid.getColIndexById("wf_name")).getValue());
            //we don'T have a jobid, server will need to find files based on the infos we have. this is currently being changed in ffastrans
             var url = ("/logparser?file=" + encodeURI(file) +"&job_end=" + encodeURI(job_end) +"&job_start=" + encodeURI(job_start) +"&wf_name=" + encodeURI(wf_name )  );
             logGrid.load(url,"json");
        } 
        win.show();
        //win.attachURL("worfklowcanvas.html?jobid=element&logfolder=element");
    });

}

function pauseResumeJob(pause,httpMethod){
//Emits socket.io comman to webserver (the api request is made on the webserver not the client) pause is set to either pause or resume. 
    if (!runningJobGrid.getSelectedRowId()){
        dhtmlx.alert("Please select a Job to " + pause);
        return;
    }    

    var selectedRowIds = runningJobGrid.getSelectedRowId().split(',');
    selectedRowIds.forEach(function(rId) {
        var jobObj = runningJobGrid.getUserData(rId,"jobobject");
        var splitid = parseInt(runningJobGrid.cells(rId,9).getValue()) ;
        var postBody = {"action": pause,"split": splitid}; 
        socket.emit("pausejob", JSON.stringify({"id":jobObj.job_id,"body":postBody}));//note, custom structure for socket.emit messages
        dhtmlx.message("Command " + pause +" emitted:" + JSON.stringify(postBody))
    })
}

function abortJobWithSplit(){
//only available in ffastrans 9.4>//TODO: wait for the new version call, then do version detection
    if (!runningJobGrid.getSelectedRowId()){
        dhtmlx.alert("Please select a Job to abort");
        return;
    }
    var selectedRowIds = runningJobGrid.getSelectedRowId().split(',');
    selectedRowIds.forEach(function(rId) {
        var jobObj = runningJobGrid.getUserData(rId,"jobobject");
        var splitid = parseInt(runningJobGrid.cells(rId,9).getValue()) 
        var postBody = {"action": "abort","split": splitid};
           $.ajax({
                url:  ("/proxy" + m_serverconfig['STATIC_START_JOB_URL']) + jobObj.job_id,
                type: "POST",
                context: this,
                data : JSON.stringify(postBody),
                success: function (response) {
                  dhtmlx.message("Aborted " + jobObj.job_id);  
                },
                error: function (xhr, status) {
                    dhtmlx.message("ERROR aborting job, contact developer. Status:" + status);
                }
            });
    })//foreachjob
}

function abortJob(){
    if (!runningJobGrid.getSelectedRowId()){
        dhtmlx.alert("Please select a Job to abort");
        return;
    }
    var selectedRowIds = runningJobGrid.getSelectedRowId().split(',');
    selectedRowIds.forEach(function(rId) {
        var rowId = rId;
        var jobObj = runningJobGrid.getUserData(rowId,"jobobject");
           $.ajax({
                url:  ("/proxy" + m_serverconfig['STATIC_START_JOB_URL']) + jobObj.job_id,
                type: "DELETE",
                context: this,
                success: function (response) {
                  dhtmlx.message("Aborted " + jobObj.job_id);  
                },
                error: function (xhr, status) {
                    dhtmlx.message("ERROR aborting job, contact developer. Status:" + status);
                }
            });
    })//foreachjob
}


function getQueuedJobs(targetGridObj){
 
    $.ajax({
        url:  buildUrl(m_serverconfig['STATIC_GET_QUEUED_JOBS_URL']),
        type: "GET",
        crossDomain: true,
        dataType: "json",
        context: this,
        success: function (response) {
             mainLayout.cells("a").progressOff();
        },
        error: function (xhr, status) {
            dhtmlx.message("ERROR getting queued jobs, possibly FFASTRANS API is offline.  ");
        }
    });
}

function addActiveJobsToGrid(targetGridObj,jobArray){
    var newjobIds = [];
    var activejobcount=0;
	console.log(jobArray)
      for (i=0;i<jobArray.length;i++){
		
        if (("splits" in jobArray[i])){//ffastrans <95
            /*
			for (splitindex=0;splitindex<jobArray[i].splits.length;splitindex++){//all running jobs have "splits" which stands for concurrent tasks. We create one row in the grid for each task
                activejobcount++;
                var splitid = 1;
                if (splitindex != 0){
                    splitid = "1" + (splitindex + 1); //ffastrans 0.9.3 does not have correct splitid in api, we have to calculate our own. it works like: (1 + (1+splitindex))
                }
                if (typeof (jobArray[i].splits[splitindex].split_id) == "number"){
                    splitid = jobArray[i].splits[splitindex].split_id; //newer ffastrans versions introduce splitid
                }

                //var rowid =  "active_" + i + splitid + jobArray[i].job_start;//split id, together with job_start we have a unique id (ffastrans does not yet deliver a unique id per split or job
                var rowid =  jobArray[i].id;//split id, together with job_start we have a unique id (ffastrans does not yet deliver a unique id per split or job

                newjobIds.push(rowid);
                var status = jobArray[i].splits[splitindex].status;           
                
                var duration = getDurationStringFromDates(rowid,jobArray[i].job_end);
                var _state = m_jobStates[jobArray[i].state];
                var progressBar = "<div class='progressbar' style='width:"+jobArray[i].splits[splitindex].progress +"%'>" + jobArray[i].splits[splitindex].progress  + "%</div>";
                if (targetGridObj.doesRowExist(rowid)){
                    //update existing task
                    targetGridObj.cells(rowid,2).setValue(jobArray[i].splits[splitindex].node);
                    targetGridObj.cells(rowid,3).setValue(jobArray[i].splits[splitindex].processor);
                    targetGridObj.cells(rowid,8).setValue(status);//todo: update more values or better all!
                    targetGridObj.cells(rowid,10).setValue(progressBar);//todo: update more values or better all!
                }else{
                    //add new task (ffastrans calls it split)
                    targetGridObj.addRow(rowid,[_state,jobArray[i].wf_name,jobArray[i].splits[splitindex].node,jobArray[i].splits[splitindex].processor,jobArray[i].file,jobArray[i].job_start,jobArray[i].job_end,duration,jobArray[i].outcome,splitid,progressBar],0);
                    targetGridObj.cells(rowid,8).setValue(status);
                }                        
                targetGridObj.setUserData(rowid,"jobobject",jobArray[i]);           //stores original job object with row for later access
                   
            }*/
        }else{
		//ffastrans version 95>
                var rowid =  jobArray[i].id + jobArray[i].split;//split id, together with job_start we have a unique id (ffastrans does not yet deliver a unique id per split or job
                newjobIds.push(rowid);
                var status = jobArray[i].status;                           
                var duration = "";
                var _state = "active";
                var progressBar = "<div class='progressbar' style='width:"+jobArray[i].progress+"%'>" + jobArray[i].progress  + "%</div>";
                if (targetGridObj.doesRowExist(rowid)){
                    //update existing task
                    targetGridObj.cells(rowid,2).setValue(jobArray[i].host);
                    targetGridObj.cells(rowid,3).setValue(jobArray[i].proc);
                    targetGridObj.cells(rowid,8).setValue(status);//todo: update more values or better all!
                    targetGridObj.cells(rowid,10).setValue(progressBar);//todo: update more values or better all!
                }else{
                    //add new task (ffastrans calls it split)
                    targetGridObj.addRow(rowid,[_state,jobArray[i].wf_name,jobArray[i].host,jobArray[i].proc,jobArray[i].file,jobArray[i].start_time,"","",status,jobArray[i].split,progressBar],0);
                    targetGridObj.cells(rowid,8).setValue(status);
                }                        
                targetGridObj.setUserData(rowid,"jobobject",jobArray[i]);           //stores original job object with row for later access
			
		}
    }
    targetGridObj.sortRows(5,"str","des");  
    //delete non existing/orphaned jobs e.g. active job got finished 
    targetGridObj.forEachRow(function(id){
        //check if we deal with a queued job
        if (newjobIds.indexOf(id)==-1){
            if (id.indexOf("queued_" )!= -1){
            }else{
                targetGridObj.deleteRow(id);
            }
        }
    });
}


function addQueuedJobsToGrid(targetGridObj,jobArray,state){//state added as of ffastrans 9.5, queued or active
	
    var newjobIds = [];
    var queuedjobcount=0;
    //add new jobs if any//TODO: at top
	
    //parse jobarray of all history jobs and add new/delete missed rows
    for (i=0;i<jobArray.length;i++){
        queuedjobcount++;
        var rowid = state + "_"+jobArray[i].id;//i is the split id, together with job_start we have a unique id (ffastrans does not yet deliver a unique id per split or job
        newjobIds.push(rowid);
        var status = "Queued"
        var duration = "";
        var _state = m_jobStates[jobArray[i].state];
        var _state = "Queued";
        if (targetGridObj.doesRowExist(rowid)){
            //no update needed for queued tasks
        }else{
            //add new job to grid
            targetGridObj.addRow(rowid,[_state,"",jobArray[i].submit.client,"",jobArray[i].sources.pretty_name,"","",jobArray[i].submit.system,"Queued"],0); 
        }                       
        var jobObj = jobArray[i];
        jobObj.job_id = jobArray[i].id;//store job_id to allow abortjobs
        targetGridObj.setRowColor(rowid,"#ffffcc");
        targetGridObj.setUserData(rowid,"jobobject",jobArray[i]);           //stores original job object with row for later access
          
    }
    targetGridObj.sortRows(5,"str","des");   
    //update job count display
    //delete jobs that are in the grid but not in the list of jobs from server
    targetGridObj.forEachRow(function(id){
        if (newjobIds.indexOf(id)==-1){
            if (id.indexOf("active_") != -1){
                //active jobs are not deleted
            }else{
                targetGridObj.deleteRow(id);
            }
        }
    });
}

/* HELPERS */
function hashCode (string) {
//this creates a hash from a stringified object, it is used to workaround and create missing jobids from ffastrans version 0.9.3
  var hash = 0, i, chr;
  if (string.length === 0) return hash;
  for (i = 0; i < string.length; i++) {
    chr   = string.charCodeAt(i);
    hash  = ((hash << 5) - hash) + chr;
    hash |= 0; // Convert to 32bit integer
  }
  return hash;
};

function getDurationStringFromDates(start_date,end_date){
        var delta = Math.abs(new Date(end_date) - new Date(start_date)) / 1000;// get total seconds between the times
        var days = Math.floor(delta / 86400);// calculate (and subtract) whole days
        delta -= days * 86400;// calculate (and subtract) whole hours
        var hours = Math.floor(delta / 3600) % 24;
        delta -= hours * 3600;// calculate (and subtract) whole minutes
        var minutes = Math.floor(delta / 60) % 60;
        delta -= minutes * 60;// what's left is seconds
        var seconds = delta % 60;  // in theory the modulus is not required
        return pad(hours) + ":" + pad (minutes) + ":" + pad (seconds);
}

function pad(n, z) { //add leading zero if there is none
  z = z || '0';
  n = n + '';
  return n.length >= 2 ? n : new Array(2 - n.length + 1).join(z) + n;
}

function configureJobGrid(dhtmlxGridObj){
        //todo: this is only for activejobgrid
        dhtmlxGridObj.setImagePath("../dependencies/dhtmlx/imgs");                 
        //dhtmlxGridObj.attachHeader("#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter"); 
        dhtmlxGridObj.setColAlign("left,left,left,left,left,left,left,left,left,left,left");       //the alignment of columns   
        dhtmlxGridObj.setColTypes("ro,ed,ed,ed,ed,ro,ed,ed,ed,ed,ed,ed,ed");                //the types of columns  
        dhtmlxGridObj.setColSorting("str,str,str,str,str,str,str,str,str,str,str,str");          //the sorting types   
        dhtmlxGridObj.enableMultiselect(true);
        dhtmlxGridObj.init();      //finishes initialization and renders the grid on the page 
}

function buildUrl(what){
    if (JSON.parse(m_serverconfig['STATIC_USE_PROXY_URL'])){
        return "/proxy" + what;
    }else{
        var _url = "http://" + m_serverconfig['STATIC_API_HOST'] + ":" + m_serverconfig['STATIC_API_PORT'] + what;
        return  _url;
    }
    //old, delete at next iteration
    
}

/* NO PROXY MODE */
function getQueuedJobs(targetGridObj){
    $.ajax({
        url:  buildUrl(m_serverconfig['STATIC_GET_QUEUED_JOBS_URL']),
        type: "GET",
        crossDomain: true,
        dataType: "json",
        context: this,
        success: function (response) {
            addQueuedJobsToGrid(targetGridObj,response.queue);
            mainLayout.cells("a").progressOff();
        },
        error: function (xhr, status) {
            dhtmlx.message("ERROR getting queued jobs, possibly FFASTRANS API is offline.  ");
        }
    });
}
function getActiveJobs(targetGridObj){
    $.ajax({
        url:  buildUrl(m_serverconfig['STATIC_GET_RUNNING_JOBS_URL']),
        type: "GET",
        crossDomain: true,
        dataType: "json",
        context: this,
        success: function (response) {
            addActiveJobsToGrid(targetGridObj,response.jobs);
            mainLayout.cells("a").progressOff();
        },
        error: function (xhr, status) {
            dhtmlx.message("ERROR getting jobs, possibly FFASTRANS API is offline.  ");
        }
    });
}
function getFinishedJobs(targetGridObj){

    $.ajax({
        url:  buildUrl(m_serverconfig['STATIC_GET_FINISHED_JOBS_URL']),
        type: "GET",
        crossDomain: true,
        dataType: "json",
        context: this,
        success: function (response) {
           addHistoryJobsToGrid(targetGridObj,response.history);
           mainLayout.cells("b").progressOff();
        },
        error: function (xhr, status) {
            dhtmlx.message("ERROR getting jobs, possibly FFASTRANS API is offline.  ");
            
        }
    });
}
/* /NO PROXY MODE */


</script>

</head>
<body onload="loadserverconfig()">

</body>