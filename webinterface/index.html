<html>

<script src="/socket.io/socket.io.js"></script>
<script src="dependencies/dhtmlx/dhtmlx.js"></script>
<link rel="stylesheet" href="dependencies/dhtmlx/dhtmlx.css" type="text/css"> 
<script src="dependencies/dhtmlx/vault/vault.js"></script>
<link rel="stylesheet" href="dependencies/dhtmlx/vault/vault.css" type="text/css"> 
<script src="dependencies/jquery/jquery.js"></script>
<link rel="icon" href="favicon.ico?v=1.1">
<link rel="stylesheet" href="dependencies/fontawesome/css/all.css"/>

<style>
    /* it's important to set width/height to 100% for full-screen init */
    html, body {
        width: 100%;
        height: 100%;
        margin: 0px;
        overflow: hidden;
        color: #333;
        font: 14px Helvetica, Arial, sans-serif;
        line-height: 18px;
    }
    header {
        background: #333;
        border-bottom: 3px solid #aaa;
        height: 80px;
    }
    header h1 {
        color: #fff;
        margin: 0 0 3px;
        font-size: 22px;
        padding: 12px 9px 0;
        margin-top: 1px;
    }
    header p {
        color: #ccc;
        font-size: 8 px;
        font-weight: bold;
        padding: 0 27px;
    }
    .counter_jobs {
      color: #ccc;
      border-radius: 5px;
      border: 2px solid #ccc;
      width: 80px;
      height: 60px;
      background-color: #333;
      font-size:20px;
      font-family:"Times New Roman";
      display:inline;
      margin-bottom: 0;
      position: absolute;
      display: block;
      font-size:12px;
      font-family:arial;
      margin-top: 8px;
    }
    .div_active_jobs {
        margin-left:350px;
    }
    .div_queued_jobs {
        margin-left:450px;
    }
    .div_success_jobs {
        margin-left:550px;
    }
    .div_error_jobs {
        margin-left:650px;
    }
    .div_cancel_jobs {
        margin-left:750px;
    }
    .itemrowtopright {
        float:right;
        margin-right:0;
        margin-top:10px;
        margin-right:10px;
        height:50px;
        color:white;
    }
    .header_counter_number{
      margin: auto;
      width: 50%;
      height: 60%;
      text-align: center;
      vertical-align: middle;
      line-height: 30px;
      font-size: 20px;
      display: block;
      margin-top: 3px;
      }
      /*.dhxlayout_base_material div.dhx_cell_layout {
          background-color: #333;
      }
      .body.dhxlayout_base_material{
          //background-color: #AAA;
      }*/
</style>

<script>
/* init SOCKET.IO */
var socket = io(); 


/* GLOBALS */
var mainLayout,runningJobGrid,finishedJobGrid,m_serverconfig;

/* STRUCTS */
var m_jobStates = ["Error","Sucess","Cancelled","Unknown"];//todo:ask steinar if there are more states and whats queued state

/*load config from server*/
function loadserverconfig(){
   $.ajax({
        url:  ("/getserverconfig") ,
        type: "GET",
        success: function (response) {
            m_serverconfig = JSON.parse(response)
            init();
        },
        error: function (xhr, status) {
            dhtmlx.message("Fatal error, could not load serverconfig. " );
            document.body.innerHTML="Fatal error, could not load serverconfig. "+ xhr.responseText;
        }
    });
}

/* build basic page layout and init periodic job loading*/
function init(){
    //check if html5 features supported
    if (typeof(Storage) !== "undefined") {
    } else {
        dhtmlx.message("ERROR, no html5 store support, cannot save view state")
    }
    headerLayout = new dhtmlXLayoutObject({
        parent: document.body,  
        pattern: "2E"           
    });
    headerLayout.cells("a").attachHTMLString('<header id="ffastrans_header"   >'+
    '<div class="counter_jobs div_active_jobs">&nbsp Running                    <div class="header_counter_number" id="activejobcount">0</div></div>'+
    '<div class="counter_jobs div_queued_jobs">&nbsp Queued     <div class="header_counter_number" id="queuedjobcount">0</div></div>'+
    '<div class="counter_jobs div_success_jobs">&nbsp Success   <div class="header_counter_number" id="successjobcount">0</div></div>'+
    '<div class="counter_jobs div_error_jobs">&nbsp Error       <div class="header_counter_number" id="errorjobcount">0</div></div>'+
    '<div class="counter_jobs div_cancel_jobs">&nbsp Cancelled  <div class="header_counter_number" id="cancelledjobcount">0</div></div>'+
    '<a href="/logout" style="cursor:pointer" class="itemrowtopright">Logout</a>'+ 
    '<a href="/admin" style="cursor:pointer" class="itemrowtopright">Admin</a>'+ 
    '<a href="https://en.wikipedia.org/wiki/Norway" style="cursor:pointer"><img src="images/viking_helmet_white.png" class="itemrowtopright"></div></a>'+
    '<a href="https://en.wikipedia.org/wiki/Austria" style="cursor:pointer"><img src="images/austria_helmet_white.png" class="itemrowtopright"></a>'+ 
    '<h1 style="cursor:pointer" ><img alt="" height="16" src="images/F364x64.png"  title="" width="16">FFAStrans</h1><p onclick="onHeaderClick()" class="description">The free automated transcoder.</p></header>');//HEADER STUFF, HEAVY USE OF CUSTOM CSS (which is unusual, the rest of the page relies on dhtmlx)
    headerLayout.cells("a").hideHeader();
    headerLayout.cells("b").hideHeader();
    headerLayout.cells("a").setHeight(75);
    headerLayout.cells("a").fixSize(true, true);
    
    mainLayout = headerLayout.cells("b").attachLayout({
        parent: document.body,  
        pattern: "3J"           
    });
    mainLayout.cells("a").setText("Running");
    
    mainLayout.cells("b").setText("New Job");
    mainLayout.cells("b").setWidth($(document).width()/3);
    mainLayout.cells("c").setText("Finished");
    mainLayout.cells("a").setHeight($(document).height()/3.5);
    saveRestoreUserState();

    runningJobGrid = mainLayout.cells("a").attachGrid();
    finishedJobGrid = mainLayout.cells("c").attachGrid();

    var headerMenu = mainLayout.cells("a").attachMenu({                                               
        items:[
             {id:"abort", text:'<i class="fas fa-stop"></i>Abort'},
             {id:"pause", text:'<i class="fas fa-pause"></i>Pause'}, 
             {id:"resume", text:'<i class="fas fa-play"></i>Resume'},
             {id:"log", text:'<i class="fas fa-info"></i>Log'},
          ]
    });
    
    var headerMenuFinished = mainLayout.cells("c").attachMenu({                                               
        items:[
             {id:"log", text:'<i class="fas fa-info"></i>Log'},
          ]
    });
    
//events for button clicks
    headerMenu.attachEvent("onClick", function(id, zoneId, cas){
            if (id == "abort") {
                abortJob()
            }
            if (id == "pause") {
                pauseResumeJob(id)
            }
            if (id == "resume") {
                pauseResumeJob(id)
            }
            if (id == "log") {
                openLogViewer(runningJobGrid)
            }
    });
    headerMenuFinished.attachEvent("onClick", function(id, zoneId, cas){
            if (id == "log") {
                openLogViewer(finishedJobGrid)
            }
    });
    
    mainLayout.cells("b").attachHTMLString("<iframe src='components/jobstarter.html' width='100%' height='100%' />");
    runningJobGrid.setInitWidthsP(m_serverconfig['STATIC_INIT_RUNNING_GRID_COL_WIDTHS_PERCENT']);          //the widths of columns 
    runningJobGrid.setHeader("State,Workflow,Node,Processor,File,Job Start,Job End,Duration,Status,Splitindex");//the headers of columns      
    configureJobGrid(runningJobGrid);
    finishedJobGrid.setInitWidthsP(m_serverconfig['STATIC_INIT_FINISHED_GRID_COL_WIDTHS_PERCENT']);          //the widths of columns  
    finishedJobGrid.setHeader("State,Workflow,Node,Processor,File,Job Start,Job End,Duration,Outcome");//the headers of columns 
    configureJobGrid(finishedJobGrid);    
    finishedJobGrid.setSortImgState(true,5,"desc");
    runningJobGrid.setSortImgState  (true,5,"desc");  
    mainLayout.cells("a").progressOn();
    mainLayout.cells("c").progressOn();
    
    /* events from socket.io*/
    socket.on('activejobs', function(msg){
        mainLayout.cells("a").progressOff();
        //instead of polling periodically from the client, the server polls periodically and notifies connected clients with the job arrays
        addActiveJobsToGrid(runningJobGrid,JSON.parse(msg))
    });
    socket.on('historyjobs', function(msg){
        mainLayout.cells("c").progressOff();
        addHistoryJobsToGrid(finishedJobGrid,JSON.parse(msg))
    });
    socket.on('queuedjobs', function(msg){
        //TODO: queued jobs dont seem to work in ffastrans 9.3
        addQueuedJobsToGrid(runningJobGrid,JSON.parse(msg))
        return;
        mainLayout.cells("c").progressOff();

    });
    socket.on('error', function(msg){
     dhtmlx.message(msg);
    });
    socket.on('msg', function(msg){
     dhtmlx.message(msg);
    });
}

function onHeaderClick(){
    window.open("http://www.ffastrans.com");
}

function openLogViewer(dhxgrid){
    if (!dhxgrid.getSelectedRowId()){
        dhtmlx.alert("Please select a Job" );
        return;
    }
    var selectedRowIds = dhxgrid.getSelectedRowId().split(',');
    var win_offset = 0;
    selectedRowIds.forEach(function(rId) {
        var jobObj = dhxgrid.getUserData(rId,"jobobject");
        var dhxwins = new dhtmlXWindows();
        dhxwins.attachViewportTo(window.parent.document.body);
        var win = dhxwins.createWindow("Workflow",  50 + win_offset, 150 + win_offset, 1200, 800);
        win_offset+=30;
        //win.denyMove();//moving and resizing behaves strange, possibly because of svg content. TODO: open workflow in new tab
        win.setText("Log ");
        //win.keepInViewport(true);
        var logGrid = win.attachGrid();
        
        logGrid.setImagePath("dependencies/dhtmlx/imgs");                 
        logGrid.setHeader("Time,Processor,Host,PID,Message");//the headers of columns  
        logGrid.attachHeader("#text_filter,#text_filter,#text_filter,#text_filter,#text_filter");  
        logGrid.setInitWidthsP("10,10,10,5,*");          //the widths of columns  
        logGrid.setColAlign("left,left,left,left.left");       //the alignment of columns   
        logGrid.setColTypes("ed,ed,ed,ed,ed");                //the types of columns  
        logGrid.setColSorting("str,str,str,int,str");          //the sorting types    
        logGrid.enableMultiline(true); 
        logGrid.init();      //finishes initialization and renders the grid on the page 
        
        if (jobObj.job_id){
            //we have a job_id that eases the life of finding jobs
            var url = "/logparser?job_id=" +encodeURI(jobObj.job_id) +"&wf_name=" + encodeURI(jobObj.wf_name) ;
            logGrid.load(url,"json")
        }else{
            //we don'T have a jobid, server will need to find files based on the infos we have. TODO: ask steinar if we can get a jobid for history jobs
             var url = ("/logparser?file=" + encodeURI(jobObj.file) +"&job_end=" + encodeURI(jobObj.job_end) +"&job_start=" + encodeURI(jobObj.job_start) +"&wf_name=" + encodeURI(jobObj.wf_name )  );
             logGrid.load(url,"json");
        } 
        win.show();
        //win.attachURL("components/worfklowcanvas.html?jobid=element&logfolder=element");
    });

}

function pauseResumeJob(pause){
//Emits socket.io comman to webserver (the api request is made on the webserver not the client) pause is set to either pause or resume. 
    if (!runningJobGrid.getSelectedRowId()){
        dhtmlx.alert("Please select a Job to " + pause);
        return;
    }    

    var selectedRowIds = runningJobGrid.getSelectedRowId().split(',');
    selectedRowIds.forEach(function(rId) {
        var jobObj = runningJobGrid.getUserData(rId,"jobobject");
        var splitid = parseInt(runningJobGrid.cells(rId,9).getValue()) ;
        var postBody = {"action": pause,"split": splitid};//TODO: ask steinar why the api does not work for multiple splits, it seems a bit random if splitid 0 or 1 is used, even using postman, if a job has 2 splits, how to pause both?
        socket.emit("pausejob", JSON.stringify({"id":jobObj.job_id,"body":postBody}));//note, custom structure for socket.emit messages
        dhtmlx.message("Command " + pause +" emitted:" + JSON.stringify(postBody))
    })
}

function abortJob(){
    if (!runningJobGrid.getSelectedRowId()){
        dhtmlx.alert("Please select a Job to abort");
        return;
    }
    var selectedRowIds = runningJobGrid.getSelectedRowId().split(',');
    selectedRowIds.forEach(function(rId) {
        var rowId = rId;
        var jobObj = runningJobGrid.getUserData(rowId,"jobobject");
           $.ajax({
                url:  ("/proxy" + m_serverconfig['STATIC_START_JOB_URL']) + jobObj.job_id,
                type: "DELETE",
                context: this,
                success: function (response) {
                  dhtmlx.message("Aborted " + jobObj.job_id);  
                },
                error: function (xhr, status) {
                    dhtmlx.message("ERROR aborting job, contact developer. Status:" + status);
                }
            });
    })//foreachjob
}


function saveRestoreUserState(){
//stores some layout properties in html5 local store

//collapsed state
    mainLayout.attachEvent("onCollapse", function(name){
        localStorage.setItem("mainLayoutCell_"+name+"_Collapsed", mainLayout.cells(name).isCollapsed());
    });
    mainLayout.attachEvent("onExpand", function(name){
        localStorage.setItem("mainLayoutCell_"+name+"_Collapsed", mainLayout.cells(name).isCollapsed());
        if (name == "b"){
            //due to bug in dhtmlx that makes bottom right cell full screen on expand, we just reload the content
            mainLayout.cells("b").attachHTMLString("<iframe src='components/jobstarter.html' width='100%' height='100%' />");
        }
    });
    if (localStorage.getItem("mainLayoutCell_a_Collapsed") == "true"){
        mainLayout.cells("a").collapse();
    } 
    if (localStorage.getItem("mainLayoutCell_b_Collapsed") == "true"){
        mainLayout.cells("b").collapse();
    } 
    if (localStorage.getItem("mainLayoutCell_c_Collapsed") == "true"){
        mainLayout.cells("c").collapse();
    } 
}

function getQueuedJobs(targetGridObj){
//todo: make this work
    $.ajax({
        url:  buildUrl(m_serverconfig['STATIC_GET_QUEUED_JOBS_URL']),
        type: "GET",
        crossDomain: true,
        dataType: "json",
        context: this,
        success: function (response) {
            //todo: find a way that queued jobs does not influence active jobs, e.g. parse state in addHistoryJobsToGrid function
            mainLayout.cells("a").progressOff();
        },
        error: function (xhr, status) {
            dhtmlx.message("ERROR getting queued jobs, possibly FFASTRANS API is offline.  ");
        }
    });
}

function addActiveJobsToGrid(targetGridObj,jobArray){
    var newjobIds = [];
    var activejobcount=0;
    //add new jobs if any//TODO: at top
    for (i=0;i<jobArray.length;i++){
        
        if (("splits" in jobArray[i])){
            for (splitindex=0;splitindex<jobArray[i].splits.length;splitindex++){//all running jobs have "splits" which stands for concurrent tasks. We create one row in the grid for each task
                activejobcount++;
                var splitid = 1;
                if (splitindex != 0){
                    splitid = "1" + (splitindex + 1); //ffastrans 0.9.3 does not have correct splitid in api, we have to calculate our own. it works like: (1 + (1+splitindex))
                }
                if (typeof (jobArray[i].splits[splitindex].split_id) == "number"){
                    splitid = jobArray[i].splits[splitindex].split_id; //newer ffastrans versions introduce splitid
                }

                var rowid =  "active_" + i + splitid + jobArray[i].job_start;//split id, together with job_start we have a unique id (ffastrans does not yet deliver a unique id per split or job
                newjobIds.push(rowid);
                var status = jobArray[i].splits[splitindex].processor + "@" + jobArray[i].splits[splitindex].node + " " + jobArray[i].splits[splitindex].status + " Progress: " + jobArray[i].splits[splitindex].progress;           
                
                var duration = getDurationStringFromDates(rowid,jobArray[i].job_end);
                var _state = m_jobStates[jobArray[i].state];
                if (targetGridObj.doesRowExist(rowid)){
                    //update existing task
                    targetGridObj.cells(rowid,2).setValue(jobArray[i].splits[splitindex].node);
                    targetGridObj.cells(rowid,3).setValue(jobArray[i].splits[splitindex].processor);
                    targetGridObj.cells(rowid,8).setValue(status);//todo: update more values or better all!
                }else{
                    //add new task (ffastrans calls it split)
                    targetGridObj.addRow(rowid,[_state,jobArray[i].wf_name,jobArray[i].splits[splitindex].node,jobArray[i].splits[splitindex].processor,jobArray[i].file,jobArray[i].job_start,jobArray[i].job_end,duration,jobArray[i].outcome,splitid],0);
                    targetGridObj.cells(rowid,8).setValue(status);
                }                        
                targetGridObj.setUserData(rowid,"jobobject",jobArray[i]);           //stores original job object with row for later access
                targetGridObj.sortRows(5,"str","des");     
            }
        }      
    }
    //update job count display
     document.getElementById("activejobcount").innerHTML = activejobcount;
    //delete non existing/orphaned jobs e.g. active job got finished 
    targetGridObj.forEachRow(function(id){
        //check if we deal with a queued job
        if (newjobIds.indexOf(id)==-1){
            if (id.indexOf("queued_" )!= -1){
            }else{
                targetGridObj.deleteRow(id);
            }
        }
    });
}


function addQueuedJobsToGrid(targetGridObj,jobArray){
    var newjobIds = [];
    var queuedjobcount=0;
    //add new jobs if any//TODO: at top

    //parse jobarray of all history jobs and add new/delete missed rows
    for (i=0;i<jobArray.length;i++){
        queuedjobcount++;
        var rowid = "queued_"+jobArray[i].item.guid;//i is the split id, together with job_start we have a unique id (ffastrans does not yet deliver a unique id per split or job
        newjobIds.push(rowid);
        var status = "Queued"
        var duration = "";
        var _state = m_jobStates[jobArray[i].state];
        var _state = "Queued";
        if (targetGridObj.doesRowExist(rowid)){
            //no update needed for queued tasks
        }else{
            //add new job to grid
            targetGridObj.addRow(rowid,[_state,"",jobArray[i].item.host,"",jobArray[i].item.display,"","",jobArray[i].item.source,"Queued"],0); 
        }                       
        var jobObj = jobArray[i];
        jobObj.job_id = jobArray[i].item.guid;//store job_id to allow abortjobs
        targetGridObj.setRowColor(rowid,"#ffffcc");
        targetGridObj.setUserData(rowid,"jobobject",jobArray[i]);           //stores original job object with row for later access
        targetGridObj.sortRows(5,"str","des");     
    }
    //update job count display
    document.getElementById("queuedjobcount").innerHTML = queuedjobcount;
    //delete jobs that are in the grid but not in the list of jobs from server
    targetGridObj.forEachRow(function(id){
        if (newjobIds.indexOf(id)==-1){
            if (id.indexOf("active_") != -1){
                //active jobs are not deleted
            }else{
                targetGridObj.deleteRow(id);
            }
        }
    });
}

function addHistoryJobsToGrid(targetGridObj,jobArray){
    var newjobIds = [];
    var successcount = 0;
    var errorcount = 0;
    var abortedcount = 0;
           
    //add new jobs if any
    //TODO: count good and bad jobs (actually for more than a few hundred jobs we need a separate api call for num error and success
    for (i=0;i<jobArray.length;i++){
        var rowid = hashCode(JSON.stringify(jobArray[i])) + i;//TODO: the +i is just for making every entry unique, this is to workaround missing job ids and split ids in ffastrans 093. DELETE THIS WHEN 093 does not need to be supported anymore
        newjobIds.push(rowid);
        if (targetGridObj.getRowIndex(rowid) != -1 ){
            //job already exists in grid
            if (jobArray[i].state == "0"){//error
                errorcount++;
            }
            if (jobArray[i].state == "1"){//success
                successcount++;
            }
            if (jobArray[i].state == "2"){//aborted
                abortedcount++;
            }
            continue;
        }
        var duration = getDurationStringFromDates(jobArray[i].job_start,jobArray[i].job_end);
        var _state = m_jobStates[jobArray[i].state];
        targetGridObj.addRow(rowid,[_state,jobArray[i].wf_name,"finished jobs dont have nodes","finished jobs dont have processors",jobArray[i].file,jobArray[i].job_start,jobArray[i].job_end,duration,jobArray[i].outcome],0); 
        if (jobArray[i].state == "0"){//error
            targetGridObj.setRowColor(rowid,"#ffe6e6");
            errorcount++;
        }
        if (jobArray[i].state == "1"){//success
            successcount++;
        }
        if (jobArray[i].state == "2"){//aborted
            targetGridObj.setRowColor(rowid,"#ffcc80");
            abortedcount++;
        }
        targetGridObj.setUserData(rowid,"jobobject",jobArray[i]);           //stores original object with row
        targetGridObj.sortRows(5,"str","des");
    }
    // update page header job count
    document.getElementById("successjobcount").innerHTML = successcount;
    document.getElementById("errorjobcount").innerHTML = errorcount;
    document.getElementById("cancelledjobcount").innerHTML = abortedcount;
    //delete non existing/orphaned jobs e.g. active job got finished 

    targetGridObj.forEachRow(function(id){
        if (newjobIds.indexOf(id)==-1){
            targetGridObj.deleteRow(id);
        }
    });
}

/* HELPERS */
function hashCode (string) {
  var hash = 0, i, chr;
  if (string.length === 0) return hash;
  for (i = 0; i < string.length; i++) {
    chr   = string.charCodeAt(i);
    hash  = ((hash << 5) - hash) + chr;
    hash |= 0; // Convert to 32bit integer
  }
  return hash;
};

function getDurationStringFromDates(start_date,end_date){
        var delta = Math.abs(new Date(end_date) - new Date(start_date)) / 1000;// get total seconds between the times
        var days = Math.floor(delta / 86400);// calculate (and subtract) whole days
        delta -= days * 86400;// calculate (and subtract) whole hours
        var hours = Math.floor(delta / 3600) % 24;
        delta -= hours * 3600;// calculate (and subtract) whole minutes
        var minutes = Math.floor(delta / 60) % 60;
        delta -= minutes * 60;// what's left is seconds
        var seconds = delta % 60;  // in theory the modulus is not required
        return pad(hours) + ":" + pad (minutes) + ":" + pad (seconds);
}

function pad(n, z) { //add leading zero if there is none
  z = z || '0';
  n = n + '';
  return n.length >= 2 ? n : new Array(2 - n.length + 1).join(z) + n;
}

function configureJobGrid(dhtmlxGridObj){
        dhtmlxGridObj.setImagePath("dependencies/dhtmlx/imgs");                 

        dhtmlxGridObj.attachHeader("#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter");                    //filters
        //dhtmlxGridObj.setInitWidthsP("0,15,30,10,0,*");          //the widths of columns  
        dhtmlxGridObj.setColAlign("left,left,left,left,left,left,left,left,left");       //the alignment of columns   
        dhtmlxGridObj.setColTypes("ro,ed,ed,ed,ed,ro,ed,ed,ed,ed");                //the types of columns  
        dhtmlxGridObj.setColSorting("str,str,str,str,str,str,str,str,str");          //the sorting types   
        dhtmlxGridObj.enableMultiselect(true);
        dhtmlxGridObj.init();      //finishes initialization and renders the grid on the page 
}

function buildUrl(what){
    return "/proxy" + what;
    //old, delete at next iteration
    var _url = "http://" + m_serverconfig['STATIC_API_HOST'] + ":" + m_serverconfig['STATIC_API_PORT'] + what;
    return  _url;
}




</script>

</head>
<body onload="loadserverconfig()">

</body>