<html>

<script src="/socket.io/socket.io.js"></script>
<script src="dependencies/dhtmlx/dhtmlx.js"></script>
<link rel="stylesheet" href="dependencies/dhtmlx/dhtmlx.css" type="text/css"> 
<script src="dependencies/dhtmlx/vault/vault.js"></script>
<link rel="stylesheet" href="dependencies/dhtmlx/vault/vault.css" type="text/css"> 
<script src="dependencies/jquery/jquery.js"></script>
<script src="configuration/staticStrings.js"></script>
<link rel="icon" href="favicon.ico?v=1.1">
<link rel="stylesheet" href="dependencies/fontawesome/css/all.css"/>

<style>
    /* it's important to set width/height to 100% for full-screen init */
    html, body {
        width: 100%;
        height: 100%;
        margin: 0px;
        overflow: hidden;
        color: #333;
        font: 14px Helvetica, Arial, sans-serif;
        line-height: 18px;
    }
    header {
        background: #333;
        border-bottom: 3px solid #aaa;
        height: 80px;
    }
    header h1 {
        color: #fff;
        margin: 0 0 3px;
        font-size: 22px;
        padding: 12px 9px 0;
    }
    header p {
        color: #ccc;
        font-size: 8 px;
        font-weight: bold;
        padding: 0 27px;
    }
    .rcorners2 {
      border-radius: 25px;
      border: 5px solid #AAAAAA;
      padding: 20px;
      width: 80px;
      height: 70px;
      background-color:rgba(0, 0, 0, 50);
      color:white;
      font-size:20px;
      font-family:"Times New Roman";
      /* display:inline; */
      margin-left:250px;
      margin-bottom: 400px;
      position: relative;
      display: block;
    }
    .numtasks{
      margin: auto;
      width: 50%;
      height: 60%;
      padding: 10px;
      text-align: center;
      vertical-align: middle;
      line-height: 80px;
      font-size: 80px;
      display: block;
      }
</style>

<script>
/* init SOCKET.IO */
var socket = io(); 


/* GLOBALS */
var mainLayout,runningJobGrid,finishedJobGrid;

/* STRUCTS */
var m_jobStates = ["Error","Sucess","Cancelled","Unknown"];//todo:ask steinar if there are more states and whats queued state

/* build basic page layout and init periodic job loading*/
function init(){
    //check if html5 features supported
    if (typeof(Storage) !== "undefined") {
      // Code for localStorage/sessionStorage.
    } else {
        dhtmlx.message("ERROR, no html5 store support, cannot save view state")
    }
    headerLayout = new dhtmlXLayoutObject({
        parent: document.body,  
        pattern: "2E"           
    });
    headerLayout.cells("a").attachHTMLString('<header id="ffastrans_header"   ><h1 style="cursor:pointer" onclick="onHeaderClick()"><img alt="" height="16" src="images/F364x64.png" title="" width="16">FFAStrans</h1><p class="description">The free automated transcoder.</p></header>');//add <div class="rcorners2">Active<div class="numtasks">1</div></div>
    headerLayout.cells("a").hideHeader();
    headerLayout.cells("b").hideHeader();
    headerLayout.cells("a").setHeight(75);
    headerLayout.cells("a").fixSize(true, true);
    
    mainLayout = headerLayout.cells("b").attachLayout({
        parent: document.body,  
        pattern: "3J"           
    });
    mainLayout.cells("a").setText("Running");
    
    mainLayout.cells("b").setText("New Job");
    mainLayout.cells("b").setWidth($(document).width()/3);
    mainLayout.cells("c").setText("Finished");
    mainLayout.cells("a").setHeight($(document).height()/3.5);
    saveRestoreUserState();

    runningJobGrid = mainLayout.cells("a").attachGrid();
    finishedJobGrid = mainLayout.cells("c").attachGrid();

    var headerMenu = mainLayout.cells("a").attachMenu({                                               
        items:[
             {id:"abort", text:'<i class="fas fa-stop"></i>Abort'},
             {id:"pause", text:'<i class="fas fa-pause"></i>Pause'},
             {id:"resume", text:'<i class="fas fa-play"></i>Resume'},
          ]
    });
    
    //file add remove event
    headerMenu.attachEvent("onClick", function(id, zoneId, cas){
            if (id == "abort") {
                abortJob()
            }
            if (id == "pause") {
                pauseResumeJob(id)
            }
            if (id == "resume") {
                pauseResumeJob(id)
            }
    });
    mainLayout.cells("b").attachHTMLString("<iframe src='components/jobstarter.html' width='100%' height='100%' />");
    runningJobGrid.setInitWidthsP(STATIC_INIT_RUNNING_GRID_COL_WIDTHS_PERCENT);          //the widths of columns 
    runningJobGrid.setHeader("State,Workflow,Node,Processor,File,Job Start,Job End,Duration,Status,Splitindex");//the headers of columns      
    configureJobGrid(runningJobGrid);
    finishedJobGrid.setInitWidthsP(STATIC_INIT_FINISHED_GRID_COL_WIDTHS_PERCENT);          //the widths of columns  
    finishedJobGrid.setHeader("State,Workflow,Node,Processor,File,Job Start,Job End,Duration,Outcome");//the headers of columns 
    configureJobGrid(finishedJobGrid);    
    //getActiveJobs(runningJobGrid);
    //getQueuedJobs(runningJobGrid);
    //getFinishedJobs(finishedJobGrid);
    finishedJobGrid.setSortImgState(true,3,"desc");
    runningJobGrid.setSortImgState  (true,3,"desc");  
    //window.setInterval(function(){getQueuedJobs(runningJobGrid)},parseInt(STATIC_JOB_POLLING_INTERVAL));
    //window.setInterval(function(){getActiveJobs(runningJobGrid)},parseInt(STATIC_JOB_POLLING_INTERVAL));
    //window.setInterval(function(){getFinishedJobs(finishedJobGrid)},parseInt(STATIC_JOB_POLLING_INTERVAL));
    mainLayout.cells("a").progressOn();
    mainLayout.cells("c").progressOn();
    
    /* events from socket.io*/
    socket.on('activejobs', function(msg){
        mainLayout.cells("a").progressOff();
        //instead of polling periodically from the client, the server polls periodically and notifies connected clients with the job arrays
        addActiveJobsToGrid(runningJobGrid,JSON.parse(msg))
    });
    socket.on('historyjobs', function(msg){
        mainLayout.cells("c").progressOff();
        addJobsToGrid(finishedJobGrid,JSON.parse(msg))
    });
    socket.on('error', function(msg){
     dhtmlx.message(msg);
    });
    socket.on('msg', function(msg){
     dhtmlx.message(msg);
    });
}

function onHeaderClick(){
    window.open("http://www.ffastrans.com");
}

function pauseResumeJob(pause){
//Emits socket.io comman to webserver (the api request is made on the webserver not the client) pause is set to either pause or resume. 
    if (!runningJobGrid.getSelectedRowId()){
        dhtmlx.alert("Please select a Job to " + pause);
        return;
    }    
    var rowId = runningJobGrid.getSelectedRowId();
    var jobObj = runningJobGrid.getUserData(rowId,"jobobject");
    var splitid = parseInt(runningJobGrid.cells(rowId,9).getValue()) ;
    var postBody = {"action": pause,"split": splitid};//TODO: ask steinar why the api does not work for multiple splits, it seems a bit random if splitid 0 or 1 is used, even using postman, if a job has 2 splits, how to pause both?
    socket.emit("pausejob", JSON.stringify({"id":jobObj.job_id,"body":postBody}));//note, custom structure for socket.emit messages
    dhtmlx.message("Command " + pause +" emitted:" + JSON.stringify(postBody))
}

function abortJob(){
    if (!runningJobGrid.getSelectedRowId()){
        dhtmlx.alert("Please select a Job to abort");
        return;
    }
    var rowId = runningJobGrid.getSelectedRowId();
    var jobObj = runningJobGrid.getUserData(rowId,"jobobject");
       $.ajax({
            url:  ("/proxy" + STATIC_START_JOB_URL) + jobObj.job_id,
            type: "DELETE",
            context: this,
            success: function (response) {
              dhtmlx.message("Aborted " + rowId);  
            },
            error: function (xhr, status) {
                dhtmlx.message("ERROR aborting job, contact developer. Status:" + status);
            }
        });
}


function saveRestoreUserState(){
//stores some layout properties in html5 local store

//collapsed state
    mainLayout.attachEvent("onCollapse", function(name){
        localStorage.setItem("mainLayoutCell_"+name+"_Collapsed", mainLayout.cells(name).isCollapsed());
    });
    mainLayout.attachEvent("onExpand", function(name){
        localStorage.setItem("mainLayoutCell_"+name+"_Collapsed", mainLayout.cells(name).isCollapsed());
    });
    if (localStorage.getItem("mainLayoutCell_a_Collapsed") == "true"){
        mainLayout.cells("a").collapse();
    } 
    if (localStorage.getItem("mainLayoutCell_b_Collapsed") == "true"){
        mainLayout.cells("b").collapse();
    } 
    if (localStorage.getItem("mainLayoutCell_c_Collapsed") == "true"){
        mainLayout.cells("c").collapse();
    } 
    
}


function getQueuedJobs(targetGridObj){
    $.ajax({
        url:  buildUrl(STATIC_GET_QUEUED_JOBS_URL),
        type: "GET",
        crossDomain: true,
        dataType: "json",
        context: this,
        success: function (response) {
            //addJobsToGrid(targetGridObj,response.queue);
            //todo: find a way that queued jobs does not influence active jobs, e.g. parse state in addjobstogrid function
            mainLayout.cells("a").progressOff();
        },
        error: function (xhr, status) {
            dhtmlx.message("ERROR getting queued jobs, possibly FFASTRANS API is offline.  ");
        }
    });
}

/* deprecated - delete after getting out if the socket.io stuff is really really stable
function getActiveJobs(targetGridObj){
    $.ajax({
        url:  buildUrl(STATIC_GET_RUNNING_JOBS_URL),
        type: "GET",
        crossDomain: true,
        dataType: "json",
        context: this,
        success: function (response) {
            addActiveJobsToGrid(targetGridObj,response.jobs);
            mainLayout.cells("a").progressOff();
        },
        error: function (xhr, status) {
            dhtmlx.message("ERROR getting jobs, possibly FFASTRANS API is offline.  ");
        }
    });
}

function getFinishedJobs(targetGridObj){
    $.ajax({
        url:  buildUrl(STATIC_GET_FINISHED_JOBS_URL),
        type: "GET",
        crossDomain: true,
        dataType: "json",
        context: this,
        success: function (response) {
           addJobsToGrid(targetGridObj,response.history);
           mainLayout.cells("c").progressOff();
        },
        error: function (xhr, status) {
            dhtmlx.message("ERROR getting jobs, possibly FFASTRANS API is offline.  ");
            
        }
    });
}
*/

function addActiveJobsToGrid(targetGridObj,jobArray){

    var newjobIds = [];
    //add new jobs if any//TODO: at top
    for (i=0;i<jobArray.length;i++){
        if (("splits" in jobArray[i])){
            for (splitindex=0;splitindex<jobArray[i].splits.length;splitindex++){//all running jobs have "splits" which stands for concurrent tasks. We create one row in the grid for each task
                var rowid =  " " + i + splitindex + jobArray[i].job_start;//i is the split id, together with job_start we have a unique id
                newjobIds.push(rowid);
                var status = jobArray[i].splits[splitindex].processor + "@" + jobArray[i].splits[splitindex].node + " " + jobArray[i].splits[splitindex].status + " Progress: " + jobArray[i].splits[splitindex].progress;           
               
                //if (targetGridObj.getRowIndex(rowid) != -1 ){
                    //job already exists in grid
                  //  continue;
                //}
                var duration = getDurationStringFromDates(rowid,jobArray[i].job_end);
                var _state = m_jobStates[jobArray[i].state];
                if (targetGridObj.doesRowExist(rowid)){
                    //update existing task
                    targetGridObj.cells(rowid,2).setValue(jobArray[i].splits[splitindex].node);
                    targetGridObj.cells(rowid,3).setValue(jobArray[i].splits[splitindex].processor);
                    targetGridObj.cells(rowid,8).setValue(status);//todo: update more values or better all!
                }else{
                    //add new task (steinar calls it split)
                    targetGridObj.addRow(rowid,[_state,jobArray[i].wf_name,jobArray[i].splits[splitindex].node,jobArray[i].splits[splitindex].processor,jobArray[i].file,jobArray[i].job_start,jobArray[i].job_end,duration,jobArray[i].outcome,splitindex],0);
                    targetGridObj.cells(rowid,8).setValue(status);
                }                        
                targetGridObj.setUserData(rowid,"jobobject",jobArray[i]);           //stores original object with row
                targetGridObj.sortRows(5,"str","des");   
                
            }
        }      
    }
    //delete non existing/orphaned jobs e.g. active job got finished 
    targetGridObj.forEachRow(function(id){
        if (!newjobIds.includes(id)){//TODO: includes is not cross browser safe
            targetGridObj.deleteRow(id);
        }
    });
    
    
}

function addJobsToGrid(targetGridObj,jobArray){
    var newjobIds = [];
    //add new jobs if any//TODO: at top
    for (i=0;i<jobArray.length;i++){
        var rowid = jobArray[i].job_start;
        newjobIds.push(rowid);
        if (targetGridObj.getRowIndex(rowid) != -1 ){
            //job already exists in grid
            continue;
        }
        var duration = getDurationStringFromDates(rowid,jobArray[i].job_end);
        var _state = m_jobStates[jobArray[i].state];
        targetGridObj.addRow(rowid,[_state,jobArray[i].wf_name,"finished jobs dont have nodes","finished jobs dont have processors",jobArray[i].file,jobArray[i].job_start,jobArray[i].job_end,duration,jobArray[i].outcome],0); 
        if (jobArray[i].state == "0"){//error
            targetGridObj.setRowColor(rowid,"#ffe6e6");
        }
        if (jobArray[i].state == "2"){//aborted
            targetGridObj.setRowColor(rowid,"#ffcc80");
        }
        
        targetGridObj.setUserData(rowid,"jobobject",jobArray[i]);           //stores original object with row
        targetGridObj.sortRows(5,"str","des");
        
    }
    //delete non existing/orphaned jobs e.g. active job got finished 
    targetGridObj.forEachRow(function(id){
        if (!newjobIds.includes(id)){
            targetGridObj.deleteRow(id);
        }
    });
    
    
}

/* HELPERS */

function getDurationStringFromDates(start_date,end_date){
        var delta = Math.abs(new Date(end_date) - new Date(start_date)) / 1000;// get total seconds between the times
        var days = Math.floor(delta / 86400);// calculate (and subtract) whole days
        delta -= days * 86400;// calculate (and subtract) whole hours
        var hours = Math.floor(delta / 3600) % 24;
        delta -= hours * 3600;// calculate (and subtract) whole minutes
        var minutes = Math.floor(delta / 60) % 60;
        delta -= minutes * 60;// what's left is seconds
        var seconds = delta % 60;  // in theory the modulus is not required
        return pad(hours) + ":" + pad (minutes) + ":" + pad (seconds);
}

function pad(n, z) { //add leading zero if there is none
  z = z || '0';
  n = n + '';
  return n.length >= 2 ? n : new Array(2 - n.length + 1).join(z) + n;
}

function configureJobGrid(dhtmlxGridObj){
        dhtmlxGridObj.setImagePath("dependencies/dhtmlx/imgs");                 

        dhtmlxGridObj.attachHeader("#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter,#text_filter");                    //filters
        //dhtmlxGridObj.setInitWidthsP("0,15,30,10,0,*");          //the widths of columns  
        dhtmlxGridObj.setColAlign("left,left,left,left,left,left,left,left,left");       //the alignment of columns   
        dhtmlxGridObj.setColTypes("ro,ed,ed,ed,ed,ro,ed,ed,ed,ed");                //the types of columns  
        dhtmlxGridObj.setColSorting("str,str,str,str,str,str,str,str,str");          //the sorting types   
        dhtmlxGridObj.init();      //finishes initialization and renders the grid on the page 
}

function buildUrl(what){
    var _url = "http://" + STATIC_API_HOST + ":" + STATIC_API_PORT + what;
    return  _url;
}




</script>

</head>
<body onload="init()">

</body>